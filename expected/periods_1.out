SELECT setting::integer < 90600 AS pre_96,
       setting::integer < 100000 AS pre_10,
       setting::integer < 120000 AS pre_12
FROM pg_settings WHERE name = 'server_version_num';
 pre_96 | pre_10 | pre_12 
--------+--------+--------
 f      | f      | t
(1 row)

/* Install the extension */
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION periods;
/*
 * Test creating a table, dropping a column, and then dropping the whole thing;
 * without any periods.  This is to make sure the health checks don't try to do
 * anything.
 */
CREATE TABLE beeswax (col1 text, col2 date);
ALTER TABLE beeswax DROP COLUMN col1;
DROP TABLE beeswax;
/* Basic period definitions with dates */
CREATE TABLE basic (val text, s date, e date);
TABLE periods.periods;
 table_name | period_name | start_column_name | end_column_name | range_type | bounds_check_constraint 
------------+-------------+-------------------+-----------------+------------+-------------------------
(0 rows)

SELECT periods.add_period('basic', 'bp', 's', 'e');
 add_period 
------------
 t
(1 row)

TABLE periods.periods;
 table_name | period_name | start_column_name | end_column_name | range_type | bounds_check_constraint 
------------+-------------+-------------------+-----------------+------------+-------------------------
 basic      | bp          | s                 | e               | daterange  | basic_bp_check
(1 row)

SELECT periods.drop_period('basic', 'bp');
 drop_period 
-------------
 t
(1 row)

TABLE periods.periods;
 table_name | period_name | start_column_name | end_column_name | range_type | bounds_check_constraint 
------------+-------------+-------------------+-----------------+------------+-------------------------
(0 rows)

SELECT periods.add_period('basic', 'bp', 's', 'e');
 add_period 
------------
 t
(1 row)

TABLE periods.periods;
 table_name | period_name | start_column_name | end_column_name | range_type | bounds_check_constraint 
------------+-------------+-------------------+-----------------+------------+-------------------------
 basic      | bp          | s                 | e               | daterange  | basic_bp_check
(1 row)

/* Test constraints */
INSERT INTO basic (val, s, e) VALUES ('x', null, null); --fail
ERROR:  null value in column "s" violates not-null constraint
DETAIL:  Failing row contains (x, null, null).
INSERT INTO basic (val, s, e) VALUES ('x', '3000-01-01', null); --fail
ERROR:  null value in column "e" violates not-null constraint
DETAIL:  Failing row contains (x, 01-01-3000, null).
INSERT INTO basic (val, s, e) VALUES ('x', null, '1000-01-01'); --fail
ERROR:  null value in column "s" violates not-null constraint
DETAIL:  Failing row contains (x, null, 01-01-1000).
INSERT INTO basic (val, s, e) VALUES ('x', '3000-01-01', '1000-01-01'); --fail
ERROR:  new row for relation "basic" violates check constraint "basic_bp_check"
DETAIL:  Failing row contains (x, 01-01-3000, 01-01-1000).
INSERT INTO basic (val, s, e) VALUES ('x', '1000-01-01', '3000-01-01'); --success
TABLE basic;
 val |     s      |     e      
-----+------------+------------
 x   | 01-01-1000 | 01-01-3000
(1 row)

/* Test dropping the whole thing */
DROP TABLE basic;
TABLE periods.periods;
 table_name | period_name | start_column_name | end_column_name | range_type | bounds_check_constraint 
------------+-------------+-------------------+-----------------+------------+-------------------------
(0 rows)

/* Unique and Foreign Keys */
-- Unique keys are already pretty much guaranteed by the underlying features of
-- PostgreSQL, but test them anyway.
CREATE TABLE uk (id integer, s integer, e integer, CONSTRAINT uk_pkey PRIMARY KEY (id, s, e));
SELECT periods.add_period('uk', 'p', 's', 'e');
 add_period 
------------
 t
(1 row)

SELECT periods.add_unique_key('uk', ARRAY['id'], 'p', key_name => 'uk_id_p', unique_constraint => 'uk_pkey');
 add_unique_key 
----------------
 t
(1 row)

INSERT INTO uk (id, s, e) VALUES (100, 1, 3), (100, 3, 4), (100, 4, 10); -- success
INSERT INTO uk (id, s, e) VALUES (200, 1, 3), (200, 3, 4), (200, 5, 10); -- success
INSERT INTO uk (id, s, e) VALUES (300, 1, 3), (300, 3, 5), (300, 4, 10); -- fail
ERROR:  conflicting key value violates exclusion constraint "uk_id_int4range_excl"
DETAIL:  Key (id, int4range(s, e, '[)'::text))=(300, [4,10)) conflicts with existing key (id, int4range(s, e, '[)'::text))=(300, [3,5)).
CREATE TABLE fk (id integer, uk_id integer, s integer, e integer, PRIMARY KEY (id));
SELECT periods.add_period('fk', 'q', 's', 'e');
 add_period 
------------
 t
(1 row)

SELECT periods.add_foreign_key('fk', ARRAY['uk_id'], 'q', 'uk_id_p', key_name => 'fk_uk_id_q');
 add_foreign_key 
-----------------
 fk_uk_id_q
(1 row)

-- INSERT
INSERT INTO fk VALUES (0, 100, 0, 1); -- fail
ERROR:  insert or update on table "fk" violates foreign key constraint "fk_uk_id_q"
CONTEXT:  PL/pgSQL function periods.validate_foreign_key_new_row(name,jsonb) line 134 at RAISE
SQL statement "SELECT periods.validate_foreign_key_new_row(TG_ARGV[0], jnew)"
PL/pgSQL function periods.fk_insert_check() line 20 at PERFORM
INSERT INTO fk VALUES (0, 100, 0, 10); -- fail
ERROR:  insert or update on table "fk" violates foreign key constraint "fk_uk_id_q"
CONTEXT:  PL/pgSQL function periods.validate_foreign_key_new_row(name,jsonb) line 134 at RAISE
SQL statement "SELECT periods.validate_foreign_key_new_row(TG_ARGV[0], jnew)"
PL/pgSQL function periods.fk_insert_check() line 20 at PERFORM
INSERT INTO fk VALUES (0, 100, 1, 11); -- fail
ERROR:  insert or update on table "fk" violates foreign key constraint "fk_uk_id_q"
CONTEXT:  PL/pgSQL function periods.validate_foreign_key_new_row(name,jsonb) line 134 at RAISE
SQL statement "SELECT periods.validate_foreign_key_new_row(TG_ARGV[0], jnew)"
PL/pgSQL function periods.fk_insert_check() line 20 at PERFORM
INSERT INTO fk VALUES (1, 100, 1, 3); -- success
INSERT INTO fk VALUES (2, 100, 1, 10); -- success
-- UPDATE
UPDATE fk SET e = 20 WHERE id = 1; -- fail
ERROR:  insert or update on table "fk" violates foreign key constraint "fk_uk_id_q"
CONTEXT:  PL/pgSQL function periods.validate_foreign_key_new_row(name,jsonb) line 134 at RAISE
SQL statement "SELECT periods.validate_foreign_key_new_row(TG_ARGV[0], jnew)"
PL/pgSQL function periods.fk_update_check() line 19 at PERFORM
UPDATE fk SET e = 6 WHERE id = 1; -- success
UPDATE uk SET s = 2 WHERE (id, s, e) = (100, 1, 3); -- fail
ERROR:  update or delete on table "uk" violates foreign key constraint "fk_uk_id_q" on table "fk"
CONTEXT:  PL/pgSQL function periods.validate_foreign_key_old_row(name,jsonb,boolean) line 103 at RAISE
SQL statement "SELECT periods.validate_foreign_key_old_row(TG_ARGV[0], jold, true)"
PL/pgSQL function periods.uk_update_check() line 23 at PERFORM
UPDATE uk SET s = 0 WHERE (id, s, e) = (100, 1, 3); -- success
-- DELETE
DELETE FROM uk WHERE (id, s, e) = (100, 3, 4); -- fail
ERROR:  update or delete on table "uk" violates foreign key constraint "fk_uk_id_q" on table "fk"
CONTEXT:  PL/pgSQL function periods.validate_foreign_key_old_row(name,jsonb,boolean) line 103 at RAISE
SQL statement "SELECT periods.validate_foreign_key_old_row(TG_ARGV[0], jold, false)"
PL/pgSQL function periods.uk_delete_check() line 22 at PERFORM
DELETE FROM uk WHERE (id, s, e) = (200, 3, 5); -- success
DROP TABLE fk;
DROP TABLE uk;
/* FOR PORTION tests */
CREATE TABLE pricing (id1 bigserial,
                      id2 bigint GENERATED ALWAYS AS IDENTITY,
                      id3 bigint GENERATED ALWAYS AS (id1 + id2) STORED,
                      product text, min_quantity integer, max_quantity integer, price numeric);
ERROR:  syntax error at or near "("
LINE 4: ...                   id3 bigint GENERATED ALWAYS AS (id1 + id2...
                                                             ^
CREATE TABLE pricing (id1 bigserial,
                      id2 bigint GENERATED ALWAYS AS IDENTITY,
                      product text, min_quantity integer, max_quantity integer, price numeric);
CREATE TABLE pricing (id1 bigserial,
                      product text, min_quantity integer, max_quantity integer, price numeric);
ERROR:  relation "pricing" already exists
SELECT periods.add_period('pricing', 'quantities', 'min_quantity', 'max_quantity');
 add_period 
------------
 t
(1 row)

SELECT periods.add_for_portion_view('pricing', 'quantities');
 add_for_portion_view 
----------------------
 t
(1 row)

TABLE periods.for_portion_views;
 table_name | period_name |             view_name              |       trigger_name        
------------+-------------+------------------------------------+---------------------------
 pricing    | quantities  | pricing__for_portion_of_quantities | for_portion_of_quantities
(1 row)

/* Test UPDATE FOR PORTION */
INSERT INTO pricing (product, min_quantity, max_quantity, price) VALUES ('Trinket', 1, 20, 200);
TABLE pricing ORDER BY min_quantity;
 id1 | id2 | product | min_quantity | max_quantity | price 
-----+-----+---------+--------------+--------------+-------
   1 |   1 | Trinket |            1 |           20 |   200
(1 row)

-- UPDATE fully preceding
UPDATE pricing__for_portion_of_quantities SET min_quantity = 0, max_quantity = 1, price = 0;
TABLE pricing ORDER BY min_quantity;
 id1 | id2 | product | min_quantity | max_quantity | price 
-----+-----+---------+--------------+--------------+-------
   1 |   1 | Trinket |            1 |           20 |   200
(1 row)

-- UPDATE fully succeeding
UPDATE pricing__for_portion_of_quantities SET min_quantity = 30, max_quantity = 50, price = 0;
TABLE pricing ORDER BY min_quantity;
 id1 | id2 | product | min_quantity | max_quantity | price 
-----+-----+---------+--------------+--------------+-------
   1 |   1 | Trinket |            1 |           20 |   200
(1 row)

-- UPDATE fully surrounding
UPDATE pricing__for_portion_of_quantities SET min_quantity = 0, max_quantity = 100, price = 100;
TABLE pricing ORDER BY min_quantity;
 id1 | id2 | product | min_quantity | max_quantity | price 
-----+-----+---------+--------------+--------------+-------
   1 |   1 | Trinket |            1 |           20 |   100
(1 row)

-- UPDATE portion
UPDATE pricing__for_portion_of_quantities SET min_quantity = 10, max_quantity = 20, price = 80;
TABLE pricing ORDER BY min_quantity;
 id1 | id2 | product | min_quantity | max_quantity | price 
-----+-----+---------+--------------+--------------+-------
   2 |   2 | Trinket |            1 |           10 |   100
   1 |   1 | Trinket |           10 |           20 |    80
(2 rows)

-- UPDATE portion of multiple rows
UPDATE pricing__for_portion_of_quantities SET min_quantity = 5, max_quantity = 15, price = 90;
TABLE pricing ORDER BY min_quantity;
 id1 | id2 | product | min_quantity | max_quantity | price 
-----+-----+---------+--------------+--------------+-------
   3 |   3 | Trinket |            1 |            5 |   100
   2 |   2 | Trinket |            5 |           10 |    90
   1 |   1 | Trinket |           10 |           15 |    90
   4 |   4 | Trinket |           15 |           20 |    80
(4 rows)

-- If we drop the period (without CASCADE) then the FOR PORTION views should be
-- dropped, too.
SELECT periods.drop_period('pricing', 'quantities');
 drop_period 
-------------
 t
(1 row)

TABLE periods.for_portion_views;
 table_name | period_name | view_name | trigger_name 
------------+-------------+-----------+--------------
(0 rows)

-- Add it back to test the drop_for_portion_view function
SELECT periods.add_period('pricing', 'quantities', 'min_quantity', 'max_quantity');
 add_period 
------------
 t
(1 row)

SELECT periods.add_for_portion_view('pricing', 'quantities');
 add_for_portion_view 
----------------------
 t
(1 row)

-- We can't drop the the table without first dropping the FOR PORTION views
-- because Postgres will complain about dependant objects (our views) before we
-- get a chance to clean them up.
DROP TABLE pricing;
ERROR:  cannot drop table pricing because other objects depend on it
DETAIL:  view pricing__for_portion_of_quantities depends on table pricing
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
SELECT periods.drop_for_portion_view('pricing', NULL);
 drop_for_portion_view 
-----------------------
 t
(1 row)

TABLE periods.for_portion_views;
 table_name | period_name | view_name | trigger_name 
------------+-------------+-----------+--------------
(0 rows)

DROP TABLE pricing;
/* SYSTEM_TIME with date */
BEGIN;
SELECT transaction_timestamp()::date AS xd,
       transaction_timestamp()::timestamp AS xts,
       transaction_timestamp() AS xtstz
\gset
CREATE TABLE sysver_date (val text, start_date date, end_date date);
SELECT periods.add_system_time_period('sysver_date', 'start_date', 'end_date');
 add_system_time_period 
------------------------
 t
(1 row)

TABLE periods.periods;
 table_name  | period_name | start_column_name | end_column_name | range_type |    bounds_check_constraint    
-------------+-------------+-------------------+-----------------+------------+-------------------------------
 sysver_date | system_time | start_date        | end_date        | daterange  | sysver_date_system_time_check
(1 row)

INSERT INTO sysver_date DEFAULT VALUES;
SELECT val, start_date = :'xd' AS start_date_eq, end_date FROM sysver_date;
 val | start_date_eq | end_date 
-----+---------------+----------
     | t             | infinity
(1 row)

DROP TABLE sysver_date;
/* SYSTEM_TIME with timestamp without time zone */
CREATE TABLE sysver_ts (val text, start_ts timestamp without time zone, end_ts timestamp without time zone);
SELECT periods.add_system_time_period('sysver_ts', 'start_ts', 'end_ts');
 add_system_time_period 
------------------------
 t
(1 row)

TABLE periods.periods;
 table_name | period_name | start_column_name | end_column_name | range_type |   bounds_check_constraint   
------------+-------------+-------------------+-----------------+------------+-----------------------------
 sysver_ts  | system_time | start_ts          | end_ts          | tsrange    | sysver_ts_system_time_check
(1 row)

INSERT INTO sysver_ts DEFAULT VALUES;
SELECT val, start_ts = :'xts' AS start_ts_eq, end_ts FROM sysver_ts;
 val | start_ts_eq |  end_ts  
-----+-------------+----------
     | t           | infinity
(1 row)

DROP TABLE sysver_ts;
/* SYSTEM_TIME with timestamp with time zone */
CREATE TABLE sysver_tstz (val text, start_tstz timestamp with time zone, end_tstz timestamp with time zone);
SELECT periods.add_system_time_period('sysver_tstz', 'start_tstz', 'end_tstz');
 add_system_time_period 
------------------------
 t
(1 row)

TABLE periods.periods;
 table_name  | period_name | start_column_name | end_column_name | range_type |    bounds_check_constraint    
-------------+-------------+-------------------+-----------------+------------+-------------------------------
 sysver_tstz | system_time | start_tstz        | end_tstz        | tstzrange  | sysver_tstz_system_time_check
(1 row)

INSERT INTO sysver_tstz DEFAULT VALUES;
SELECT val, start_tstz = :'xtstz' AS start_tstz_eq, end_tstz FROM sysver_tstz;
 val | start_tstz_eq | end_tstz 
-----+---------------+----------
     | t             | infinity
(1 row)

DROP TABLE sysver_tstz;
COMMIT;
/* Basic SYSTEM_TIME periods with CASCADE/purge */
CREATE TABLE sysver (val text);
SELECT periods.add_system_time_period('sysver', 'startname');
 add_system_time_period 
------------------------
 t
(1 row)

SELECT periods.drop_period('sysver', 'system_time', drop_behavior => 'CASCADE', purge => true);
 drop_period 
-------------
 t
(1 row)

SELECT periods.add_system_time_period('sysver', end_column_name => 'endname');
 add_system_time_period 
------------------------
 t
(1 row)

SELECT periods.drop_period('sysver', 'system_time', drop_behavior => 'CASCADE', purge => true);
 drop_period 
-------------
 t
(1 row)

SELECT periods.add_system_time_period('sysver', 'startname', 'endname');
 add_system_time_period 
------------------------
 t
(1 row)

SELECT periods.drop_system_time_period('sysver', drop_behavior => 'CASCADE', purge => true);
 drop_system_time_period 
-------------------------
 t
(1 row)

SELECT periods.add_system_time_period('sysver', 'endname', 'startname');
 add_system_time_period 
------------------------
 t
(1 row)

SELECT periods.drop_system_time_period('sysver', drop_behavior => 'CASCADE', purge => true);
 drop_system_time_period 
-------------------------
 t
(1 row)

SELECT periods.add_system_time_period('sysver');
 add_system_time_period 
------------------------
 t
(1 row)

DROP TABLE sysver;
TABLE periods.periods;
 table_name | period_name | start_column_name | end_column_name | range_type | bounds_check_constraint 
------------+-------------+-------------------+-----------------+------------+-------------------------
(0 rows)

TABLE periods.system_time_periods;
 table_name | period_name | infinity_check_constraint | generated_always_trigger | write_history_trigger | truncate_trigger 
------------+-------------+---------------------------+--------------------------+-----------------------+------------------
(0 rows)

/* Basic SYSTEM VERSIONING */
CREATE TABLE sysver (val text);
SELECT periods.add_system_time_period('sysver');
 add_system_time_period 
------------------------
 t
(1 row)

TABLE periods.system_time_periods;
 table_name | period_name |       infinity_check_constraint       |      generated_always_trigger       |      write_history_trigger       | truncate_trigger 
------------+-------------+---------------------------------------+-------------------------------------+----------------------------------+------------------
 sysver     | system_time | sysver_system_time_end_infinity_check | sysver_system_time_generated_always | sysver_system_time_write_history | sysver_truncate
(1 row)

TABLE periods.system_versioning;
 table_name | period_name | history_table_name | view_name | func_as_of | func_between | func_between_symmetric | func_from_to 
------------+-------------+--------------------+-----------+------------+--------------+------------------------+--------------
(0 rows)

SELECT periods.add_system_versioning('sysver');
NOTICE:  history table "sysver_history" created for "sysver", be sure to index it properly
 add_system_versioning 
-----------------------
 
(1 row)

TABLE periods.system_versioning;
 table_name | period_name | history_table_name |      view_name      |               func_as_of                |                            func_between                            |                            func_between_symmetric                            |                            func_from_to                            
------------+-------------+--------------------+---------------------+-----------------------------------------+--------------------------------------------------------------------+------------------------------------------------------------------------------+--------------------------------------------------------------------
 sysver     | system_time | sysver_history     | sysver_with_history | sysver__as_of(timestamp with time zone) | sysver__between(timestamp with time zone,timestamp with time zone) | sysver__between_symmetric(timestamp with time zone,timestamp with time zone) | sysver__from_to(timestamp with time zone,timestamp with time zone)
(1 row)

INSERT INTO sysver (val) VALUES ('hello');
SELECT val FROM sysver;
  val  
-------
 hello
(1 row)

SELECT val FROM sysver_history ORDER BY system_time_start;
 val 
-----
(0 rows)

SELECT transaction_timestamp() AS ts1 \gset
UPDATE sysver SET val = 'world';
SELECT val FROM sysver;
  val  
-------
 world
(1 row)

SELECT val FROM sysver_history ORDER BY system_time_start;
  val  
-------
 hello
(1 row)

SELECT transaction_timestamp() AS ts2 \gset
DELETE FROM sysver;
SELECT val FROM sysver;
 val 
-----
(0 rows)

SELECT val FROM sysver_history ORDER BY system_time_start;
  val  
-------
 hello
 world
(2 rows)

/* temporal queries */
SELECT val FROM sysver__as_of(:'ts1') ORDER BY system_time_start;
  val  
-------
 hello
(1 row)

SELECT val FROM sysver__as_of(:'ts2') ORDER BY system_time_start;
  val  
-------
 world
(1 row)

SELECT val FROM sysver__from_to(:'ts1', :'ts2') ORDER BY system_time_start;
  val  
-------
 hello
 world
(2 rows)

SELECT val FROM sysver__from_to(:'ts2', :'ts1') ORDER BY system_time_start;
 val 
-----
(0 rows)

SELECT val FROM sysver__between(:'ts1', :'ts2') ORDER BY system_time_start;
  val  
-------
 hello
 world
(2 rows)

SELECT val FROM sysver__between(:'ts2', :'ts1') ORDER BY system_time_start;
 val 
-----
(0 rows)

SELECT val FROM sysver__between_symmetric(:'ts1', :'ts2') ORDER BY system_time_start;
  val  
-------
 hello
 world
(2 rows)

SELECT val FROM sysver__between_symmetric(:'ts2', :'ts1') ORDER BY system_time_start;
  val  
-------
 hello
 world
(2 rows)

/* TRUNCATE should delete the history, too */
SELECT val FROM sysver_with_history;
  val  
-------
 hello
 world
(2 rows)

TRUNCATE sysver;
SELECT val FROM sysver_with_history; --empty
 val 
-----
(0 rows)

/* Try modifying several times in a transaction */
BEGIN;
INSERT INTO sysver (val) VALUES ('hello');
INSERT INTO sysver (val) VALUES ('world');
ROLLBACK;
SELECT val FROM sysver_with_history; --empty
 val 
-----
(0 rows)

BEGIN;
INSERT INTO sysver (val) VALUES ('hello');
UPDATE sysver SET val = 'world';
UPDATE sysver SET val = 'world2';
UPDATE sysver SET val = 'world3';
DELETE FROM sysver;
COMMIT;
SELECT val FROM sysver_with_history; --empty
 val 
-----
(0 rows)

-- We can't drop the the table without first dropping SYSTEM VERSIONING because
-- Postgres will complain about dependant objects (our view functions) before
-- we get a chance to clean them up.
DROP TABLE sysver;
ERROR:  cannot drop table sysver because other objects depend on it
DETAIL:  view sysver_with_history depends on table sysver
function sysver__as_of(timestamp with time zone) depends on type sysver_with_history
function sysver__between(timestamp with time zone,timestamp with time zone) depends on type sysver_with_history
function sysver__between_symmetric(timestamp with time zone,timestamp with time zone) depends on type sysver_with_history
function sysver__from_to(timestamp with time zone,timestamp with time zone) depends on type sysver_with_history
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
SELECT periods.drop_system_versioning('sysver', drop_behavior => 'CASCADE', purge => true);
 drop_system_versioning 
------------------------
 t
(1 row)

TABLE periods.system_versioning;
 table_name | period_name | history_table_name | view_name | func_as_of | func_between | func_between_symmetric | func_from_to 
------------+-------------+--------------------+-----------+------------+--------------+------------------------+--------------
(0 rows)

DROP TABLE sysver;
TABLE periods.periods;
 table_name | period_name | start_column_name | end_column_name | range_type | bounds_check_constraint 
------------+-------------+-------------------+-----------------+------------+-------------------------
(0 rows)

TABLE periods.system_time_periods;
 table_name | period_name | infinity_check_constraint | generated_always_trigger | write_history_trigger | truncate_trigger 
------------+-------------+---------------------------+--------------------------+-----------------------+------------------
(0 rows)

/* Forbid UNIQUE keys on system_time columns */
CREATE TABLE no_unique (col1 timestamp with time zone, s bigint, e bigint);
SELECT periods.add_period('no_unique', 'p', 's', 'e');
 add_period 
------------
 t
(1 row)

SELECT periods.add_unique_key('no_unique', ARRAY['col1'], 'p'); -- passes
 add_unique_key 
----------------
 t
(1 row)

SELECT periods.add_system_time_period('no_unique');
 add_system_time_period 
------------------------
 t
(1 row)

SELECT periods.add_unique_key('no_unique', ARRAY['system_time_start'], 'p'); -- fails
ERROR:  columns in period for SYSTEM_TIME are not allowed in UNIQUE keys
CONTEXT:  PL/pgSQL function periods.add_unique_key(regclass,name[],name,name,name,name) line 78 at RAISE
SELECT periods.add_unique_key('no_unique', ARRAY['system_time_end'], 'p'); -- fails
ERROR:  columns in period for SYSTEM_TIME are not allowed in UNIQUE keys
CONTEXT:  PL/pgSQL function periods.add_unique_key(regclass,name[],name,name,name,name) line 78 at RAISE
SELECT periods.add_unique_key('no_unique', ARRAY['col1'], 'system_time'); -- fails
ERROR:  periods for SYSTEM_TIME are not allowed in UNIQUE keys
CONTEXT:  PL/pgSQL function periods.add_unique_key(regclass,name[],name,name,name,name) line 35 at RAISE
SELECT periods.drop_system_time_period('no_unique');
 drop_system_time_period 
-------------------------
 t
(1 row)

SELECT periods.add_unique_key('no_unique', ARRAY['system_time_start'], 'p'); -- passes
 add_unique_key 
----------------
 t
(1 row)

SELECT periods.add_unique_key('no_unique', ARRAY['system_time_end'], 'p'); -- passes
 add_unique_key 
----------------
 t
(1 row)

SELECT periods.add_system_time_period('no_unique'); -- fails
ERROR:  columns in period for SYSTEM_TIME are not allowed in UNIQUE keys
CONTEXT:  PL/pgSQL function periods.add_system_time_period(regclass,name,name) line 51 at RAISE
SELECT periods.drop_unique_key('no_unique', 'no_unique_system_time_start_p');
 drop_unique_key 
-----------------
 
(1 row)

SELECT periods.drop_unique_key('no_unique', 'no_unique_system_time_end_p');
 drop_unique_key 
-----------------
 
(1 row)

/* Forbid foreign keys on system_time columns */
CREATE TABLE no_unique_ref (LIKE no_unique);
SELECT periods.add_period('no_unique_ref', 'q', 's', 'e');
 add_period 
------------
 t
(1 row)

SELECT periods.add_system_time_period('no_unique_ref');
 add_system_time_period 
------------------------
 t
(1 row)

SELECT periods.add_foreign_key('no_unique_ref', ARRAY['system_time_start'], 'q', 'no_unique_col1_p'); -- fails
ERROR:  columns in period for SYSTEM_TIME are not allowed in UNIQUE keys
CONTEXT:  PL/pgSQL function periods.add_foreign_key(regclass,name[],name,name,periods.fk_match_types,periods.fk_actions,periods.fk_actions,name) line 50 at RAISE
SELECT periods.add_foreign_key('no_unique_ref', ARRAY['system_time_end'], 'q', 'no_unique_col1_p'); -- fails
ERROR:  columns in period for SYSTEM_TIME are not allowed in UNIQUE keys
CONTEXT:  PL/pgSQL function periods.add_foreign_key(regclass,name[],name,name,periods.fk_match_types,periods.fk_actions,periods.fk_actions,name) line 50 at RAISE
SELECT periods.add_foreign_key('no_unique_ref', ARRAY['col1'], 'system_time', 'no_unique_col1_p'); -- fails
ERROR:  periods for SYSTEM_TIME are not allowed in foreign keys
CONTEXT:  PL/pgSQL function periods.add_foreign_key(regclass,name[],name,name,periods.fk_match_types,periods.fk_actions,periods.fk_actions,name) line 38 at RAISE
SELECT periods.drop_system_time_period('no_unique_ref');
 drop_system_time_period 
-------------------------
 t
(1 row)

SELECT periods.add_foreign_key('no_unique_ref', ARRAY['system_time_start'], 'q', 'no_unique_col1_p'); -- passes
          add_foreign_key          
-----------------------------------
 no_unique_ref_system_time_start_q
(1 row)

SELECT periods.add_foreign_key('no_unique_ref', ARRAY['system_time_end'], 'q', 'no_unique_col1_p'); -- passes
         add_foreign_key         
---------------------------------
 no_unique_ref_system_time_end_q
(1 row)

SELECT periods.add_system_time_period('no_unique_ref'); -- fails
ERROR:  columns for SYSTEM_TIME must not be part of foreign keys
CONTEXT:  PL/pgSQL function periods.add_system_time_period(regclass,name,name) line 171 at RAISE
DROP TABLE no_unique, no_unique_ref;
/* DROP protection */
CREATE TYPE integerrange AS RANGE (SUBTYPE = integer);
CREATE TABLE dp (
    id bigint,
    s integer,
    e integer
);
/* periods */
SELECT periods.add_period('dp', 'p', 's', 'e', 'integerrange');
 add_period 
------------
 t
(1 row)

DROP TYPE integerrange;
ERROR:  cannot drop rangetype "public.integerrange" because it is used in period "p" on table "dp"
CONTEXT:  PL/pgSQL function periods.drop_protection() line 56 at RAISE
/* system_time_periods */
SELECT periods.add_system_time_period('dp');
 add_system_time_period 
------------------------
 t
(1 row)

ALTER TABLE dp DROP CONSTRAINT dp_system_time_end_infinity_check; -- fails
ERROR:  cannot drop constraint "dp_system_time_end_infinity_check" on table "dp" because it is used in SYSTEM_TIME period
CONTEXT:  PL/pgSQL function periods.drop_protection() line 72 at RAISE
DROP TRIGGER dp_system_time_generated_always ON dp; -- fails
ERROR:  cannot drop trigger "dp_system_time_generated_always" on table "dp" because it is used in SYSTEM_TIME period
CONTEXT:  PL/pgSQL function periods.drop_protection() line 84 at RAISE
DROP TRIGGER dp_system_time_write_history ON dp; -- fails
ERROR:  cannot drop trigger "dp_system_time_write_history" on table "dp" because it is used in SYSTEM_TIME period
CONTEXT:  PL/pgSQL function periods.drop_protection() line 96 at RAISE
DROP TRIGGER dp_truncate ON dp; -- fails
ERROR:  cannot drop trigger "dp_truncate" on table "dp" because it is used in SYSTEM_TIME period
CONTEXT:  PL/pgSQL function periods.drop_protection() line 108 at RAISE
/* for_portion_views */
SELECT periods.add_for_portion_view('dp', 'p');
 add_for_portion_view 
----------------------
 t
(1 row)

DROP VIEW dp__for_portion_of_p;
ERROR:  cannot drop view "public.dp__for_portion_of_p", call "periods.drop_for_portion_view()" instead
CONTEXT:  PL/pgSQL function periods.drop_protection() line 125 at RAISE
DROP TRIGGER for_portion_of_p ON dp__for_portion_of_p;
ERROR:  cannot drop trigger "for_portion_of_p" on table "dp" because it is used in FOR PORTION OF view for period "p"
CONTEXT:  PL/pgSQL function periods.drop_protection() line 137 at RAISE
SELECT periods.drop_for_portion_view('dp', 'p');
 drop_for_portion_view 
-----------------------
 t
(1 row)

/* unique_keys */
ALTER TABLE dp
    ADD CONSTRAINT u UNIQUE (id, s, e),
    ADD CONSTRAINT x EXCLUDE USING gist (id WITH =, integerrange(s, e, '[)') WITH &&);
SELECT periods.add_unique_key('dp', ARRAY['id'], 'p', 'k', 'u', 'x');
 add_unique_key 
----------------
 t
(1 row)

ALTER TABLE dp DROP CONSTRAINT u; -- fails
ERROR:  cannot drop constraint "u" on table "dp" because it is used in period unique key "k"
CONTEXT:  PL/pgSQL function periods.drop_protection() line 158 at RAISE
ALTER TABLE dp DROP CONSTRAINT x; -- fails
ERROR:  cannot drop constraint "x" on table "dp" because it is used in period unique key "k"
CONTEXT:  PL/pgSQL function periods.drop_protection() line 169 at RAISE
ALTER TABLE dp DROP CONSTRAINT dp_p_check; -- fails
/* foreign_keys */
CREATE TABLE dp_ref (LIKE dp);
SELECT periods.add_period('dp_ref', 'p', 's', 'e', 'integerrange');
 add_period 
------------
 t
(1 row)

SELECT periods.add_foreign_key('dp_ref', ARRAY['id'], 'p', 'k', key_name => 'f');
 add_foreign_key 
-----------------
 f
(1 row)

DROP TRIGGER f_fk_insert ON dp_ref; -- fails
ERROR:  cannot drop trigger "f_fk_insert" on table "dp_ref" because it is used in period foreign key "f"
CONTEXT:  PL/pgSQL function periods.drop_protection() line 185 at RAISE
DROP TRIGGER f_fk_update ON dp_ref; -- fails
ERROR:  cannot drop trigger "f_fk_update" on table "dp_ref" because it is used in period foreign key "f"
CONTEXT:  PL/pgSQL function periods.drop_protection() line 196 at RAISE
DROP TRIGGER f_uk_update ON dp; -- fails
ERROR:  cannot drop trigger "f_uk_update" on table "dp" because it is used in period foreign key "f"
CONTEXT:  PL/pgSQL function periods.drop_protection() line 208 at RAISE
DROP TRIGGER f_uk_delete ON dp; -- fails
ERROR:  cannot drop trigger "f_uk_delete" on table "dp" because it is used in period foreign key "f"
CONTEXT:  PL/pgSQL function periods.drop_protection() line 220 at RAISE
SELECT periods.drop_foreign_key('dp_ref', 'f');
 drop_foreign_key 
------------------
 t
(1 row)

DROP TABLE dp_ref;
/* system_versioning */
SELECT periods.add_system_versioning('dp');
NOTICE:  history table "dp_history" created for "dp", be sure to index it properly
 add_system_versioning 
-----------------------
 
(1 row)

-- Note: The history table is protected by the history view and the history
-- view is protected by the temporal functions.
DROP TABLE dp_history CASCADE;
NOTICE:  drop cascades to 5 other objects
DETAIL:  drop cascades to view dp_with_history
drop cascades to function dp__as_of(timestamp with time zone)
drop cascades to function dp__between(timestamp with time zone,timestamp with time zone)
drop cascades to function dp__between_symmetric(timestamp with time zone,timestamp with time zone)
drop cascades to function dp__from_to(timestamp with time zone,timestamp with time zone)
ERROR:  cannot drop table "public.dp_history" because it is used in SYSTEM VERSIONING for table "dp"
CONTEXT:  PL/pgSQL function periods.drop_protection() line 236 at RAISE
DROP VIEW dp_with_history CASCADE;
NOTICE:  drop cascades to 4 other objects
DETAIL:  drop cascades to function dp__as_of(timestamp with time zone)
drop cascades to function dp__between(timestamp with time zone,timestamp with time zone)
drop cascades to function dp__between_symmetric(timestamp with time zone,timestamp with time zone)
drop cascades to function dp__from_to(timestamp with time zone,timestamp with time zone)
ERROR:  cannot drop view "public.dp_with_history" because it is used in SYSTEM VERSIONING for table "dp"
CONTEXT:  PL/pgSQL function periods.drop_protection() line 248 at RAISE
DROP FUNCTION dp__as_of(timestamp with time zone);
ERROR:  cannot drop function "public.dp__as_of(timestamp with time zone)" because it is used in SYSTEM VERSIONING for table "dp"
CONTEXT:  PL/pgSQL function periods.drop_protection() line 260 at RAISE
DROP FUNCTION dp__between(timestamp with time zone,timestamp with time zone);
ERROR:  cannot drop function "public.dp__between(timestamp with time zone,timestamp with time zone)" because it is used in SYSTEM VERSIONING for table "dp"
CONTEXT:  PL/pgSQL function periods.drop_protection() line 260 at RAISE
DROP FUNCTION dp__between_symmetric(timestamp with time zone,timestamp with time zone);
ERROR:  cannot drop function "public.dp__between_symmetric(timestamp with time zone,timestamp with time zone)" because it is used in SYSTEM VERSIONING for table "dp"
CONTEXT:  PL/pgSQL function periods.drop_protection() line 260 at RAISE
DROP FUNCTION dp__from_to(timestamp with time zone,timestamp with time zone);
ERROR:  cannot drop function "public.dp__from_to(timestamp with time zone,timestamp with time zone)" because it is used in SYSTEM VERSIONING for table "dp"
CONTEXT:  PL/pgSQL function periods.drop_protection() line 260 at RAISE
SELECT periods.drop_system_versioning('dp', purge => true);
 drop_system_versioning 
------------------------
 t
(1 row)

DROP TABLE dp;
DROP TYPE integerrange;
/* RENAME following */
/* periods */
CREATE TABLE rename_test(col1 text, col2 bigint, col3 time, s integer, e integer);
SELECT periods.add_period('rename_test', 'p', 's', 'e');
 add_period 
------------
 t
(1 row)

TABLE periods.periods;
 table_name  | period_name | start_column_name | end_column_name | range_type | bounds_check_constraint 
-------------+-------------+-------------------+-----------------+------------+-------------------------
 rename_test | p           | s                 | e               | int4range  | rename_test_p_check
(1 row)

ALTER TABLE rename_test RENAME s TO start;
ALTER TABLE rename_test RENAME e TO "end";
TABLE periods.periods;
 table_name  | period_name | start_column_name | end_column_name | range_type | bounds_check_constraint 
-------------+-------------+-------------------+-----------------+------------+-------------------------
 rename_test | p           | start             | end             | int4range  | rename_test_p_check
(1 row)

ALTER TABLE rename_test RENAME start TO "s < e";
TABLE periods.periods;
 table_name  | period_name | start_column_name | end_column_name | range_type | bounds_check_constraint 
-------------+-------------+-------------------+-----------------+------------+-------------------------
 rename_test | p           | s < e             | end             | int4range  | rename_test_p_check
(1 row)

ALTER TABLE rename_test RENAME "end" TO "embedded "" symbols";
TABLE periods.periods;
 table_name  | period_name | start_column_name |  end_column_name   | range_type | bounds_check_constraint 
-------------+-------------+-------------------+--------------------+------------+-------------------------
 rename_test | p           | s < e             | embedded " symbols | int4range  | rename_test_p_check
(1 row)

ALTER TABLE rename_test RENAME CONSTRAINT rename_test_p_check TO start_before_end;
TABLE periods.periods;
 table_name  | period_name | start_column_name |  end_column_name   | range_type | bounds_check_constraint 
-------------+-------------+-------------------+--------------------+------------+-------------------------
 rename_test | p           | s < e             | embedded " symbols | int4range  | start_before_end
(1 row)

/* system_time_periods */
SELECT periods.add_system_time_period('rename_test');
 add_system_time_period 
------------------------
 t
(1 row)

TABLE periods.system_time_periods;
 table_name  | period_name |         infinity_check_constraint          |         generated_always_trigger         |         write_history_trigger         |   truncate_trigger   
-------------+-------------+--------------------------------------------+------------------------------------------+---------------------------------------+----------------------
 rename_test | system_time | rename_test_system_time_end_infinity_check | rename_test_system_time_generated_always | rename_test_system_time_write_history | rename_test_truncate
(1 row)

ALTER TABLE rename_test RENAME CONSTRAINT rename_test_system_time_end_infinity_check TO inf_check;
ALTER TRIGGER rename_test_system_time_generated_always ON rename_test RENAME TO generated_always;
ALTER TRIGGER rename_test_system_time_write_history ON rename_test RENAME TO write_history;
ALTER TRIGGER rename_test_truncate ON rename_test RENAME TO trunc;
TABLE periods.system_time_periods;
 table_name  | period_name | infinity_check_constraint | generated_always_trigger | write_history_trigger | truncate_trigger 
-------------+-------------+---------------------------+--------------------------+-----------------------+------------------
 rename_test | system_time | inf_check                 | generated_always         | write_history         | trunc
(1 row)

/* for_portion_views */
SELECT periods.add_for_portion_view('rename_test', 'p');
 add_for_portion_view 
----------------------
 t
(1 row)

TABLE periods.for_portion_views;
 table_name  | period_name |           view_name           |   trigger_name   
-------------+-------------+-------------------------------+------------------
 rename_test | p           | rename_test__for_portion_of_p | for_portion_of_p
(1 row)

ALTER TRIGGER for_portion_of_p ON rename_test__for_portion_of_p RENAME TO portion_trigger;
TABLE periods.for_portion_views;
 table_name  | period_name |           view_name           |  trigger_name   
-------------+-------------+-------------------------------+-----------------
 rename_test | p           | rename_test__for_portion_of_p | portion_trigger
(1 row)

SELECT periods.drop_for_portion_view('rename_test', 'p');
 drop_for_portion_view 
-----------------------
 t
(1 row)

/* unique_keys */
SELECT periods.add_unique_key('rename_test', ARRAY['col2', 'col1', 'col3'], 'p');
 add_unique_key 
----------------
 t
(1 row)

TABLE periods.unique_keys;
           key_name           | table_name  |   column_names   | period_name |                    unique_constraint                    |            exclude_constraint             
------------------------------+-------------+------------------+-------------+---------------------------------------------------------+-------------------------------------------
 rename_test_col2_col1_col3_p | rename_test | {col2,col1,col3} | p           | rename_test_col2_col1_col3_s < e_embedded " symbols_key | rename_test_col2_col1_col3_int4range_excl
(1 row)

ALTER TABLE rename_test RENAME COLUMN col1 TO "COLUMN1";
ALTER TABLE rename_test RENAME CONSTRAINT "rename_test_col2_col1_col3_s < e_embedded "" symbols_key" TO unconst;
ALTER TABLE rename_test RENAME CONSTRAINT rename_test_col2_col1_col3_int4range_excl TO exconst;
TABLE periods.unique_keys;
           key_name           | table_name  |    column_names     | period_name | unique_constraint | exclude_constraint 
------------------------------+-------------+---------------------+-------------+-------------------+--------------------
 rename_test_col2_col1_col3_p | rename_test | {col2,COLUMN1,col3} | p           | unconst           | exconst
(1 row)

/* foreign_keys */
CREATE TABLE rename_test_ref (LIKE rename_test);
SELECT periods.add_period('rename_test_ref', 'q', 's < e', 'embedded " symbols');
 add_period 
------------
 t
(1 row)

SELECT periods.add_foreign_key('rename_test_ref', ARRAY['col2', 'COLUMN1', 'col3'], 'q', 'rename_test_col2_col1_col3_p');
           add_foreign_key           
-------------------------------------
 rename_test_ref_col2_COLUMN1_col3_q
(1 row)

TABLE periods.foreign_keys;
              key_name               |   table_name    |    column_names     | period_name |          unique_key          | match_type | delete_action | update_action |               fk_insert_trigger               |               fk_update_trigger               |               uk_update_trigger               |               uk_delete_trigger               
-------------------------------------+-----------------+---------------------+-------------+------------------------------+------------+---------------+---------------+-----------------------------------------------+-----------------------------------------------+-----------------------------------------------+-----------------------------------------------
 rename_test_ref_col2_COLUMN1_col3_q | rename_test_ref | {col2,COLUMN1,col3} | q           | rename_test_col2_col1_col3_p | SIMPLE     | NO ACTION     | NO ACTION     | rename_test_ref_col2_COLUMN1_col3_q_fk_insert | rename_test_ref_col2_COLUMN1_col3_q_fk_update | rename_test_ref_col2_COLUMN1_col3_q_uk_update | rename_test_ref_col2_COLUMN1_col3_q_uk_delete
(1 row)

ALTER TABLE rename_test_ref RENAME COLUMN "COLUMN1" TO col1; -- fails
ERROR:  cannot drop or rename column "COLUMN1" on table "rename_test_ref" because it is used in period foreign key "rename_test_ref_col2_COLUMN1_col3_q"
CONTEXT:  PL/pgSQL function periods.rename_following() line 194 at RAISE
ALTER TRIGGER "rename_test_ref_col2_COLUMN1_col3_q_fk_insert" ON rename_test_ref RENAME TO fk_insert;
ERROR:  cannot drop or rename trigger "rename_test_ref_col2_COLUMN1_col3_q_fk_insert" on table "rename_test_ref" because it is used in period foreign key "rename_test_ref_col2_COLUMN1_col3_q"
CONTEXT:  PL/pgSQL function periods.rename_following() line 229 at RAISE
ALTER TRIGGER "rename_test_ref_col2_COLUMN1_col3_q_fk_update" ON rename_test_ref RENAME TO fk_update;
ERROR:  cannot drop or rename trigger "rename_test_ref_col2_COLUMN1_col3_q_fk_update" on table "rename_test_ref" because it is used in period foreign key "rename_test_ref_col2_COLUMN1_col3_q"
CONTEXT:  PL/pgSQL function periods.rename_following() line 229 at RAISE
ALTER TRIGGER "rename_test_ref_col2_COLUMN1_col3_q_uk_update" ON rename_test RENAME TO uk_update;
ERROR:  cannot drop or rename trigger "rename_test_ref_col2_COLUMN1_col3_q_uk_update" on table "rename_test" because it is used in period foreign key "rename_test_ref_col2_COLUMN1_col3_q"
CONTEXT:  PL/pgSQL function periods.rename_following() line 229 at RAISE
ALTER TRIGGER "rename_test_ref_col2_COLUMN1_col3_q_uk_delete" ON rename_test RENAME TO uk_delete;
ERROR:  cannot drop or rename trigger "rename_test_ref_col2_COLUMN1_col3_q_uk_delete" on table "rename_test" because it is used in period foreign key "rename_test_ref_col2_COLUMN1_col3_q"
CONTEXT:  PL/pgSQL function periods.rename_following() line 229 at RAISE
TABLE periods.foreign_keys;
              key_name               |   table_name    |    column_names     | period_name |          unique_key          | match_type | delete_action | update_action |               fk_insert_trigger               |               fk_update_trigger               |               uk_update_trigger               |               uk_delete_trigger               
-------------------------------------+-----------------+---------------------+-------------+------------------------------+------------+---------------+---------------+-----------------------------------------------+-----------------------------------------------+-----------------------------------------------+-----------------------------------------------
 rename_test_ref_col2_COLUMN1_col3_q | rename_test_ref | {col2,COLUMN1,col3} | q           | rename_test_col2_col1_col3_p | SIMPLE     | NO ACTION     | NO ACTION     | rename_test_ref_col2_COLUMN1_col3_q_fk_insert | rename_test_ref_col2_COLUMN1_col3_q_fk_update | rename_test_ref_col2_COLUMN1_col3_q_uk_update | rename_test_ref_col2_COLUMN1_col3_q_uk_delete
(1 row)

DROP TABLE rename_test_ref;
/* system_versioning */
-- Nothing to do here
DROP TABLE rename_test;
/* Health checks */
CREATE UNLOGGED TABLE log (id bigint, s date, e date);
SELECT periods.add_period('log', 'p', 's', 'e'); -- fails
ERROR:  table "log" must be persistent
CONTEXT:  PL/pgSQL function periods.add_period(regclass,name,name,name,regtype) line 72 at RAISE
SELECT periods.add_system_time_period('log'); -- fails
ERROR:  table "log" must be persistent
CONTEXT:  PL/pgSQL function periods.add_system_time_period(regclass,name,name) line 77 at RAISE
ALTER TABLE log SET LOGGED;
SELECT periods.add_period('log', 'p', 's', 'e'); -- passes
 add_period 
------------
 t
(1 row)

SELECT periods.add_system_time_period('log'); -- passes
 add_system_time_period 
------------------------
 t
(1 row)

ALTER TABLE log SET UNLOGGED; -- fails
ERROR:  table "log" must remain persistent because it has periods
CONTEXT:  PL/pgSQL function periods.health_checks() line 13 at RAISE
SELECT periods.add_system_versioning('log');
NOTICE:  history table "log_history" created for "log", be sure to index it properly
 add_system_versioning 
-----------------------
 
(1 row)

ALTER TABLE log_history SET UNLOGGED; -- fails
ERROR:  history table "log" must remain persistent because it has periods
CONTEXT:  PL/pgSQL function periods.health_checks() line 24 at RAISE
SELECT periods.drop_system_versioning('log', purge => true);
 drop_system_versioning 
------------------------
 t
(1 row)

DROP TABLE log;
/* Clean up */
DROP EXTENSION periods;
